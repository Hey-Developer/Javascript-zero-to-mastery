/* 
$ Error handling: 
  If a promise resolves normally, then await promise returns the result. But in the case of a rejection, it throws the error, just as if there were a throw statement at that line.
  
  This code:
  async function f() {
    await Promise.reject(new Error("Whoops!"));
  }

  …is the same as this:
  async function f() {
    throw new Error("Whoops!");
  }

--In real situations, the promise may take some time before it reject, In that case there will be a delay before await throws an error.
  
~We can catch that error using try..catch, the same way as a regular throw:
*/

// async function f() {

//   try {
//     let response = await fetch('http://no-such-url');
//   } catch(err) {
//     alert(err); // TypeError: failed to fetch
//   }
// }

// f();

// -->Without error Handling..
async function f1() {
    await Promise.reject(new Error("Whoops!"));
}
// f1();
/* 
! Error on the console..
Uncaught (in promise) Error: Whoops!
    f http://127.0.0.1:5500/JS_Advance/Asynchronous_JS/async-await-error-handling.js:33
    <anonymous> http://127.0.0.1:5500/JS_Advance/Asynchronous_JS/async-await-error-handling.js:35
*/


// --> Error handling with try catch..
async function f3() {
    try {
        let response = await fetch("/no-user-here");
        let user = await response.json();
    } catch (err) {
        // catches errors both in fetch and response.json
        alert(err);
    }
}

f3();

// --If we don’t have try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append .catch to handle it:

// -->Error handling with .catch
async function f2() {
    await Promise.reject(new Error("Whoops!"));
}
f2().catch(err => console.log(err)); // (*)

// !When we use async/await, we rarely need .then, because await handles the waiting for us. And we can use a regular try..catch instead of .catch. That’s usually (but not always) more convenient.

// !But at the top level of the code, when we’re outside any async function, we’re syntactically unable to use await, so it’s a normal practice to add .then/catch to handle the final result or falling-through error, like in the line (*) of the example above.

// $async/await works well with Promise.all
// wait for the array of results
let results = await Promise.all([
    fetch(url1),
    fetch(url2),
    ...
]);


/* 
$ Summary:
  --1.The async keyword before a function has two effects:
      >Makes it always return a promise.
      >Allows await to be used in it.

  --2>The await keyword before a promise makes JavaScript wait until that promise settles, and then:
      >If it’s an error, the exception is generated — same as if throw error were called at that very place.
      >Otherwise, it returns the result.

*/